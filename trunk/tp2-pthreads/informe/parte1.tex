\part{Introducci\'on y Correctitud}

\section{Introducci\'on}

Para la resolucion del problema planteado se decidio implementar un nuevo backend. Este nuevo backend llamado backend_multi, contempla el acceso de multiples clientes al juego SOScrable. Para realizar esto correctamente la implementacion del nuevo backend tiene que estar libre de condiciones de carrera y ademas:
Permitir que multiples clientes se conecten al backend de forma simultanea
Permitir que todos los jugadores coloquen letras en casilleros distintos de forma simultanea
Permitir que varios clientes consulten el estado del tablero de forma simultanea 

Para realizar lo anteriormente pedido se utiliza pthreads. La utilizacion threads acarrea el problema de condicion de carrera. Para contemplar los accesos de distintos threads a las variables globales de manera correcta se agregaron un mutex (\verb|pthread_mutex_t m|), una variable de condicion(\verb|pthread_cond_t vc|) y una variable global(\verb|bool cliente_inicializado|).

\section{Correctiud}

Entonces, para verificar que se cumple que todas las funciones del backend son thread-safe realizamos el siguiente analisis:

Aquellas funciones funciones que no modifican ni acceden a ninguna de las variables globales las consideramos thread-safe. Estas son \verb|cargar_int()|, \verb|recibir_nombre()|, \verb|recibir_comando()|, \verb|parsear_casillero()|, \verb|enviar_dimensiones()|, \verb|enviar_ok()|, \verb|enviar_error()|, \verb|cerrar_servidor()|, \verb|casillero_mas_distante()| y \verb|puso_letra_en()|.

Y para aquellas funciones que acceden a variables globales pero no fueron sincronizadas las consideramos no thread-safe. Estas van a tener que ser siempre usadas en bloques de sincronizacion. Estas son \verb|quitar_letras()| y \verb|es_ficha_valida_en_palabra()|.

Para ver que todas las funciones que no son thread-safe son llamadas correctamente analicemos el siguiente pseudocodigo:
